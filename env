 # env/trading_env.py
 """
 Custom Gymnasium trading environment simulating realistic market conditions.
 """
 import gymnasium as gym
 from gymnasium import spaces
 import numpy as np
 import pandas as pd
 class TradingEnv(gym.Env):
 """
    Trading environment: actions {0=hold, 1=buy, 2=sell}. 
    Observation = [current_price, net_worth, position].
    Simulates slippage and transaction costs.
    """
 metadata = {"render.modes": ["human"]}
 def __init__(self, data: pd.DataFrame, initial_balance: float = 10000.0,
 transaction_cost: float = 0.001, slippage: float = 0.001):
 super(TradingEnv, self).__init__()
 self.data = data.reset_index(drop=True)
 self.prices = self.data["Close"].values
 self.initial_balance = initial_balance
 self.transaction_cost = transaction_cost
 self.slippage = slippage
 self.current_step = 0
 self.position = 0 # 0=flat, 1=long
 self.balance = initial_balance
 self.shares_held = 0
 self.net_worth = initial_balance
 # Action space: hold, buy, sell
 self.action_space = spaces.Discrete(3)
 # Observation: [price, net_worth, position]
 high = np.array([np.finfo(np.float32).max, np.finfo(np.float32).max,
 1.0])
 low = np.array([0.0, 0.0,-1.0])
 self.observation_space = spaces.Box(low=low, high=high,
 dtype=np.float32)
def reset(self):
 self.current_step = 0
 self.position = 0
 self.balance = self.initial_balance
 self.shares_held = 0
 self.net_worth = self.initial_balance
 return self._get_observation(), {}
 def _get_observation(self):
 price = self.prices[self.current_step]
 obs = np.array([price, self.net_worth, float(self.position)],
 dtype=np.float32)
 return obs
 def step(self, action):
 """
        Execute one time step: trade according to the action.
        """
 price = self.prices[self.current_step]
 prev_worth = self.net_worth
 # Buy action
 if action == 1:
 buy_price = price * (1 + self.slippage)
 # Calculate number of shares to buy
 max_shares = self.balance // (buy_price * (1 +
 self.transaction_cost))
 if max_shares > 0:
 cost = max_shares * buy_price * (1 + self.transaction_cost)
 self.balance-= cost
 self.shares_held += max_shares
 self.position = 1
 # Sell action
 elif action == 2:
 sell_price = price * (1-self.slippage)
 if self.shares_held > 0:
 proceeds = self.shares_held * sell_price * (1
self.transaction_cost)
 self.balance += proceeds
 self.shares_held = 0
 self.position = 0
 # Advance step
 self.current_step += 1
 done = self.current_step >= len(self.prices)-1
# Update net worth
 new_price = self.prices[self.current_step]
 self.net_worth = self.balance + self.shares_held * new_price
 reward = self.net_worth- prev_worth # profit as reward
 info = {"net_worth": self.net_worth}
 return self._get_observation(), reward, done, False, info
 def render(self, mode="human"):
 print(f"Step: {self.current_step}")
 print(f"Price: {self.prices[self.current_step]:.2f}, Position: 
{self.position}, Net worth: {self.net_worth:.2f}")
